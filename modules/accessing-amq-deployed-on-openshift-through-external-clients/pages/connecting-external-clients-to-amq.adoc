#  Connecting external clients to AMQ

== Accessing AMQ deployed on OpenShift through external clients

    Once Red Hat AMQ is successfully deployed and configured on OpenShift, external clients can be connected to it to send and receive messages. This section will guide you through the process of connecting external clients to AMQ and managing their interactions.

    ### Connecting External Clients to AMQ

    To connect external clients to AMQ deployed on OpenShift, you need to use a messaging protocol supported by AMQ, such as AMQP, MQTT, OpenMAUD, or STOMP. Here, we'll focus on AMQP using the Qpid Dispatch Router as an intermediary.

    **Prerequisites:**

    1. An external client with a messaging library that supports AMQP (e.g., Python's `amqp` library, Java's `qpid-jmx` library, or Node.js's `amqplib`).
    2. The OpenShift cluster should have network access to the AMQ brokers.

    **Steps to Connect External Clients:**

    1. **Install the Qpid Dispatch Router:**

        Deploy the Qpid Dispatch Router on a machine that has network access to both the OpenShift cluster and the external clients. You can use the following command to deploy the router on a Linux machine:

        ```
        sudo yum install -y qpid-dispatch-router
        ```

    2. **Configure the Qpid Dispatch Router:**

        Create a router configuration file (`router.conf`) with the necessary inter-broker and client connections. Here's a basic example:

        ```
        connector {
            host: <AMQ_BROKER_HOST>
            port: <AMQ_BROKER_PORT>
            role: normal
        }

        connector {
            host: <EXTERNAL_CLIENT_HOST>
            port: <EXTERNAL_CLIENT_PORT>
            role: normal
        }

        listener {
            host: 0.0.0.0
            port: 5672
            role: inter_router
        }

        address {
            prefix: amq
            policy: catch_and_store
        }
        ```

        Replace `<AMQ_BROKER_HOST>`, `<AMQ_BROKER_PORT>`, `<EXTERNAL_CLIENT_HOST>`, and `<EXTERNAL_CLIENT_PORT>` with the appropriate values.

    3. **Start the Qpid Dispatch Router:**

        Start the router using the following command:

        ```
        sudo systemctl start qpid-dispatch-router
        ```

    4. **Connect External Clients:**

        Use#  Connecting external clients to AMQ

[#_connecting_external_clients_to_amq]
= Connecting External Clients to AMQ

Understanding how to connect external clients to your Red Hat AMQ brokers deployed on OpenShift is crucial for integrating your enterprise applications. This section will detail the mechanisms OpenShift provides for external access and guide you through the process of establishing a connection from an application outside your OpenShift cluster.

== How External Access Works in OpenShift for AMQ

When you deploy Red Hat AMQ on OpenShift, the AMQ Broker typically runs within a pod. To make this broker accessible from outside the OpenShift cluster, OpenShift utilizes `Service` and `Route` (or `LoadBalancer`/`NodePort` Services depending on configuration and cloud provider capabilities) resources.

=== OpenShift Services
Within OpenShift, a `Service` acts as an internal load balancer and a stable network endpoint for a set of pods. For AMQ, the AMQ Operator automatically creates `Service` resources that target your AMQ Broker pods. These Services provide cluster-internal DNS names and IP addresses, enabling other applications within the OpenShift cluster to connect to the broker.

=== OpenShift Routes
To expose the AMQ Broker *externally* beyond the OpenShift cluster, you typically use an OpenShift `Route`. A Route exposes a Service at a host name, such as `amq-broker-external.apps.mycluster.example.com`.

For message-oriented middleware like AMQ, which often uses non-HTTP/HTTPS protocols (like AMQP, OpenWire, STOMP, MQTT), OpenShift Routes can be configured for *passthrough* TCP traffic. In a passthrough configuration, the OpenShift router forwards raw TCP connections directly to the backing Service without terminating TLS or inspecting application-layer protocols at the router. This is essential for protocols that manage their own session and TLS negotiation, allowing the AMQ broker to handle the entire connection lifecycle, including TLS handshake, directly.

.Key Considerations for External Client Connectivity
*   **Protocol Support**: Red Hat AMQ supports various messaging protocols, including AMQP 1.0, OpenWire, STOMP, MQTT, and JMS. Ensure your client library uses a protocol supported by your AMQ broker.
*   **Endpoint Identification**: Clients need the correct hostname and port to connect. This information is typically derived from the OpenShift Route.
*   **Security (TLS/SSL)**: For production environments, always encrypt traffic using TLS/SSL. The AMQ Operator can configure the broker with TLS certificates, and the OpenShift Route should be set up for TLS passthrough to ensure end-to-end encryption.
*   **Authentication and Authorization**: Clients will need valid credentials (username and password) to authenticate with the AMQ broker. If configured, external identity providers can also be used for advanced authentication.
*   **Firewall Rules**: Ensure that any network firewalls between your external client and the OpenShift cluster's ingress are configured to allow traffic on the required ports (typically 443 for TLS passthrough Routes, or specific protocol ports like 5672 for AMQP, 61616 for OpenWire if using NodePorts or LoadBalancers).

== Hands-on Activity: Connecting an External Client to AMQ

This activity will guide you through identifying the external access details for your AMQ broker and then connecting to it using a simple client application. We will use AMQP as the protocol for this demonstration.

=== Prerequisites

Before starting this activity, ensure you have:

*   An OpenShift cluster with the OpenShift CLI (`oc`) configured and logged in as a user with sufficient permissions.
*   Red Hat AMQ Broker deployed and running on OpenShift, preferably using the AMQ Broker Operator. (This would typically be set up in a previous lab, e.g., "Deploying and configuring AMQ on OpenShift").
*   A client machine (your workstation, for example) with network access to the OpenShift cluster's ingress.
*   Python installed on your client machine for the example client script.

=== Step 1: Identify AMQ Broker External Access Details

First, we need to find the external hostname and port that your AMQ broker is exposed through. We'll assume a passthrough Route for AMQP has been created by the AMQ Operator during the broker deployment.

. Log in to your OpenShift cluster:
+
[source,bash]
----
oc login --token=<your_token> --server=<your_api_server>
----

. Switch to the project where your AMQ broker is deployed. Replace `my-amq-project` with the actual name of your project:
+
[source,bash]
----
oc project my-amq-project
----

. List the Routes in your project to find the AMQ broker's external endpoint. Look for a Route that corresponds to AMQP, often indicated by `amqp` in its name or service:
+
[source,bash]
----
oc get routes
----
+
You should see output similar to this:
+
[source,text]
----
NAME                            HOST/PORT                                                            PATH   SERVICES                  PORT        TERMINATION          WILDCARD
amq-broker-external-amqp        amq-broker-external-amqp-my-amq-project.apps.cluster.example.com             amq-broker-service        <all>       passthrough          None
amq-broker-external-console     amq-broker-external-console-my-amq-project.apps.cluster.example.com          amq-broker-service-jolokia  jolokia     reencrypt            None
----
+
From the output, identify the `HOST/PORT` for the AMQP route. For our example, let's use `amq-broker-external-amqp-my-amq-project.apps.cluster.example.com`. The `TERMINATION` column showing `passthrough` is key, as it indicates the broker handles TLS directly. For passthrough routes, the external port is typically 443, as the OpenShift router listens on this port for TLS traffic.

. (Optional) Inspect the Route details for specific ports or configurations:
+
[source,bash]
----
oc describe route amq-broker-external-amqp
----
+
In the description, confirm the `Host` and `TLS Termination` (`passthrough`). The external port will be the standard HTTPS port (443) for a TLS passthrough route.

. **Record the external hostname and port.** For the purpose of this lab, let's assume your AMQP external hostname is `amq-broker-external-amqp-my-amq-project.apps.cluster.example.com` and the port is `443`.

. Identify AMQ Broker Credentials
+
By default, the AMQ Broker Operator may create a secret containing credentials for a default user (e.g., `user`/`password`). You can find these credentials by inspecting the secrets related to your `ActiveMQArtemis` custom resource.
+
[source,bash]
----
oc get secret <broker-cr-name>-credentials -o jsonpath='{.data.username}' | base64 -d
oc get secret <broker-cr-name>-credentials -o jsonpath='{.data.password}' | base64 -d
----
+
Replace `<broker-cr-name>` with the name of your `ActiveMQArtemis` custom resource (e.g., `amq-broker`).
+
**Record the username and password.** For this lab, we will assume the default `user` and `password` for simplicity.

=== Step 2: Prepare a Simple AMQP Client

We'll use a simple Python client with the `qpid-proton` library to connect to the AMQ broker.

. On your client machine (outside OpenShift), install the `qpid-proton` library:
+
[source,bash]
----
pip install python-qpid-proton
----

. Create a new Python file named `amqp_connect_test.py` with the following content:
+
[source,python]
----
from proton.handlers import MessagingHandler
from proton.reactor import Container
import ssl

class Client(MessagingHandler):
    """
    A simple AMQP client handler to establish and verify a connection.
    """
    def __init__(self, url, username, password):
        super(Client, self).__init__()
        self.url = url
        self.username = username
        self.password = password
        self.connected = False

    def on_start(self, event):
        """Called when the client starts."""
        print(f"Attempting to connect to: {self.url}")
        
        # Connection options, including authentication
        conn_options = {
            'username': self.username,
            'password': self.password
        }
        
        # For secure connections (TLS), use 'amqps' scheme.
        # If your AMQ broker uses self-signed certificates or a custom CA
        # not trusted by your client machine's default trust store,
        # you might need to configure ssl_domain to trust the CA:
        #
        # ssl_domain = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        # ssl_domain.load_verify_locations(cafile="/path/to/your/ca.crt")
        # ssl_domain.verify_mode = ssl.CERT_REQUIRED # or ssl.CERT_NONE for testing (NOT RECOMMENDED for production)
        # conn_options['ssl_domain'] = ssl_domain

        # Initiate the connection
        event.container.connect(self.url, **conn_options)
        print("Connection initiated. Waiting for connection open event...")

    def on_connection_opened(self, event):
        """Called when the AMQP connection is successfully opened."""
        print(f"SUCCESS: Connection opened to {event.connection.remote_hostname}")
        self.connected = True
        print("Successfully connected to AMQ Broker. Connection can be established.")
        event.connection.close() # Close connection after successful handshake

    def on_connection_closed(self, event):
        """Called when the AMQP connection is closed."""
        print(f"INFO: Connection closed to {event.connection.remote_hostname}")

    def on_disconnected(self, event):
        """Called when the client disconnects from the broker."""
        if not self.connected:
            print(f"ERROR: Disconnected from {event.connection.remote_hostname} without successful connection.")
        else:
            print(f"INFO: Disconnected from {event.connection.remote_hostname} after successful connection.")
        event.container.stop() # Stop the event loop

    def on_error(self, event):
        """Called when an error occurs during connection."""
        print(f"ERROR: An error occurred: {event.error}")
        self.connected = False
        event.container.stop() # Stop the event loop in case of error

if __name__ == "__main__":
    # <<<<<<< IMPORTANT: Replace these values with your actual broker details and credentials >>>>>>>
    
    # Construct the broker URL using the 'amqps' scheme for TLS and the identified hostname and port.
    # For a passthrough route on OpenShift, the external port is typically 443.
    broker_hostname = "amq-broker-external-amqp-my-amq-project.apps.cluster.example.com" # Replace with your recorded hostname
    broker_port = 443 # Default for TLS passthrough routes
    broker_url = f"amqps://{broker_hostname}:{broker_port}" 
    
    amq_username = "user"     # Replace with your AMQ username
    amq_password = "password" # Replace with your AMQ password

    print("Starting AMQP client to test connection...")
    try:
        Container(Client(broker_url, amq_username, amq_password)).run()
    except Exception as e:
        print(f"FATAL: An error occurred during client execution: {e}")

----

=== Step 3: Run the AMQP Client

. Execute the Python script you just created:
+
[source,bash]
----
python amqp_connect_test.py
----

. Observe the output. If the connection is successful, you should see messages similar to:
+
[source,text]
----
Starting AMQP client to test connection...
Attempting to connect to: amqps://amq-broker-external-amqp-my-amq-project.apps.cluster.example.com:443
Connection initiated. Waiting for connection open event...
SUCCESS: Connection opened to amq-broker-external-amqp-my-amq-project.apps.cluster.example.com:443
Successfully connected to AMQ Broker. Connection can be established.
INFO: Connection closed to amq-broker-external-amqp-my-amq-project.apps.cluster.example.com:443
INFO: Disconnected from amq-broker-external-amqp-my-amq-project.apps.cluster.example.com:443 after successful connection.
----

If you encounter issues, consider the following troubleshooting steps:

*   **Incorrect Hostname/Port**: Double-check the `broker_hostname` and `broker_port` in your `amqp_connect_test.py` script against the `oc get routes` output and your identified values.
*   **Firewall Issues**: Ensure your client machine has network connectivity to the OpenShift cluster's ingress on the specified port (e.g., 443). Test basic connectivity with `ping` or `telnet` (though `telnet` won't show TLS success, it can confirm port reachability).
*   **TLS Certificate Issues**: If your AMQ broker uses a self-signed certificate or a CA not trusted by your client's operating system, the `qpid-proton` library (and underlying SSL libraries) might refuse the connection. For development/testing, you might temporarily set `ssl_domain.verify_mode = ssl.CERT_NONE` *within your Python script* (not recommended for production). The robust solution is to add the CA certificate to your client's trust store or configure the client to explicitly trust the broker's certificate chain.
*   **Authentication Failures**: Verify the `amq_username` and `amq_password` in your script exactly match the credentials configured on your AMQ broker, as retrieved from the OpenShift Secret.
*   **Route Configuration**: Ensure the OpenShift Route for AMQP is indeed configured for `passthrough` TLS termination. If it's `reencrypt` or `edge`, the router will terminate TLS, and a different client configuration might be required (e.g., client might need to trust the router's certificate, or the AMQP protocol may not be handled correctly if the router expects HTTP).

This concludes the process of connecting an external client to your Red Hat AMQ broker on OpenShift. You have successfully identified the external endpoint and established a secure connection using a simple AMQP client. The next step would typically involve sending and receiving messages, which will be covered in the subsequent topic.